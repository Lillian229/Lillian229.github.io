(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{440:function(n,v,_){"use strict";_.r(v);var t=_(34),r=Object(t.a)({},(function(){var n=this,v=n.$createElement,_=n._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[_("h1",{attrs:{id:"时间复杂度"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂度"}},[n._v("#")]),n._v(" 时间复杂度")]),n._v(" "),_("h2",{attrs:{id:"为什么需要复杂度分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要复杂度分析"}},[n._v("#")]),n._v(" 为什么需要复杂度分析？")]),n._v(" "),_("p",[n._v("事后统计法：把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小。")]),n._v(" "),_("p",[n._v("这种评估算法执行效率的方法是正确的。为什么还要做时间、空间复杂度分析呢？这种分析方法能比实实在在跑一遍得到的数据更准确吗？\n原因：事后统计法具有局限性：")]),n._v(" "),_("ol",[_("li",[_("p",[n._v("测试结果非常依赖测试环境，测试环境中硬件的不同会对测试结果有很大的影响。")])]),n._v(" "),_("li",[_("p",[n._v("测试结果受数据规模的影响很大\n对同一个排序算法，待排序数据的有序度不一样，排序的执行时间就会有很大的差别。\n极端情况下，如果数据已经是有序的，那排序算法不需要做任何操作，执行时间就会非常短。\n除此之外，如果测试数据规模太小，测试结果可能无法真实地反应算法的性能。\n比如，对于小规模的数据排序，插入排序可能反倒会比快速排序要快！")])])]),n._v(" "),_("p",[n._v("我们需要一个"),_("strong",[n._v("不用具体的测试数据来测试，就可以粗略地估计算法的执行效率")]),n._v("的方法——"),_("strong",[n._v("时间、空间复杂度分析")]),n._v("方法。")]),n._v(" "),_("h2",{attrs:{id:"时间复杂度-大o表示法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂度-大o表示法"}},[n._v("#")]),n._v(" 时间复杂度 & 大O表示法")]),n._v(" "),_("p",[_("strong",[n._v("时间复杂度是一个函数，表示算法的执行效率，它定性描述该算法的运行时间。")])]),n._v(" "),_("p",[n._v("大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示"),_("strong",[n._v("代码执行时间随数据规模增长的变化趋势")]),n._v("，所以，也叫作渐进时间复杂（asymptotic time complexity），简称"),_("strong",[n._v("时间复杂度")]),n._v("。")]),n._v(" "),_("p",[n._v("那么该如何估计程序运行时间呢，通常会估算算法的操作单元数量来代表程序消耗的时间，这里默认CPU的每个单元运行消耗的时间都是相同的。")]),n._v(" "),_("p",[n._v("假设算法的问题规模为n，那么操作单元数量便用函数f(n)来表示，随着数据规模n的增大，算法执行时间的增长率和f(n)的增长率相同，这称作为算法的渐近时间复杂度，简称时间复杂度，记为 O(f(n))。")]),n._v(" "),_("p",[n._v("T(n) = O(f(n))\nT(n)：代码执行时间\nn：表示数据规模的大小\nf(n)：表示每行代码执行的次数总和")]),n._v(" "),_("p",[n._v("因为这是一个公式，所以用 f(n)来表示。\n"),_("strong",[n._v("公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。")])]),n._v(" "),_("p",[n._v("eg. T(n) = O(2n+2), T(n) = O(2n+2n+3)....这就是大 O 时间复杂度表示法。")]),n._v(" "),_("p",[n._v("eg.一段代码循环执行了 100 次，这一个常量的执行时间，跟 n 的规模无关。\n所以，即便这段代码循环 10000 次、100000 次，"),_("strong",[n._v("只要是一个已知的数，跟 n 无关，照样也是常量级的执行时间")]),n._v("。\n"),_("strong",[n._v("当 n 无限大的时候，就可以忽略")]),n._v("。尽管对代码的\n执行时间会有很大影响，但是回到时间复杂度的概念来说，它表示的是一个算法执行效率与数据规模增长的变化趋势，所以不管常量的执行时间多大，我们都可以忽略掉。\n因为它本身"),_("strong",[n._v("对增长趋势并没有影响")]),n._v("。")]),n._v(" "),_("h2",{attrs:{id:"时间复杂度分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂度分析"}},[n._v("#")]),n._v(" 时间复杂度分析")]),n._v(" "),_("p",[n._v("如何分析一段代码的时间复杂度？ 三个较常用方法：")]),n._v(" "),_("ol",[_("li",[n._v("只关注循环执行次数最多的一段代码\n大 O 这种复杂度表示方法只是表示一种变化趋势。可以忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。 "),_("br"),n._v("\n所以，在分析一个算法、一段代码的时间复杂度的时候，也"),_("strong",[n._v("只关注循环执行次数最多的那一段代码")]),n._v("就可以了。"),_("br"),n._v("\n这段核心代码执行次数的 n 的量级，就是整段要分析代码的时间复杂度。\n"),_("br")]),n._v(" "),_("li",[n._v("加法法则：总复杂度等于量级最大的那段代码的复杂度\n比如有三段代码，复杂度分别为执行了100次， O(n) 和 O(n)。综合这三段代码的时间复杂度，我们取其中最大的量级。所以，整段代码的时间复杂度就为O(n)。也就是说："),_("strong",[n._v("总")]),n._v("的时间复杂度就等于"),_("strong",[n._v("量级最大")]),n._v("的那段代码的时间复杂度。\n将这个规律抽象成公式就是：\n如果\nT1(n) = O(f(n))，\nT2(n) = O(g(n))；\n即T(n) = T1(n) + T2(n) = max(O(f(n)),\nO(g(n))) = O(max(f(n), g(n))).")])])])}),[],!1,null,null,null);v.default=r.exports}}]);