(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{418:function(t,s,a){"use strict";a.r(s);var e=a(34),r=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"http1-0-vs-http1-1-vs-http2-0"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http1-0-vs-http1-1-vs-http2-0"}},[t._v("#")]),t._v(" HTTP1.0 VS HTTP1.1 VS HTTP2.0")]),t._v(" "),a("p",[t._v("1991年 —— HTTP0.9\n1996年 —— HTTP1.0\n1999年 —— HTTP1.1\n2015年 —— HTTP2.0")]),t._v(" "),a("h2",{attrs:{id:"http1-0和http1-1的一些区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http1-0和http1-1的一些区别"}},[t._v("#")]),t._v(" HTTP1.0和HTTP1.1的一些区别")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("缓存处理，HTTP1.0中主要使用 Last-Modified，Expires 来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略：ETag，Cache-Control…")])]),t._v(" "),a("li",[a("p",[t._v("带宽优化及网络连接的使用，HTTP1.1支持断点续传，即返回码是206（Partial Content）")])]),t._v(" "),a("li",[a("p",[t._v("错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除…")])]),t._v(" "),a("li",[a("p",[t._v("Host头处理，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）")])]),t._v(" "),a("li",[a("p",[t._v("长连接，HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点")])])]),t._v(" "),a("h2",{attrs:{id:"http2-0和http1-x相比的新特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http2-0和http1-x相比的新特性"}},[t._v("#")]),t._v(" HTTP2.0和HTTP1.X相比的新特性")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("新的二进制格式（Binary Format），HTTP1.x的解析是基于文本，基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合，基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮")])]),t._v(" "),a("li",[a("p",[t._v("header压缩，HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小")])]),t._v(" "),a("li",[a("p",[t._v("服务端推送（server push），例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了")])])]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 通过在应用生成HTTP响应头信息中设置Link命令")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("Link")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("styles"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("css"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" rel"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("preload"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("example"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("png"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" rel"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("preload"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("image\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("ul",[a("li",[t._v("多路复用（MultiPlexing）\n"),a("ul",[a("li",[t._v("HTTP/1.0  每次请求响应，建立一个TCP连接，用完关闭")]),t._v(" "),a("li",[t._v("HTTP/1.1 「长连接」 若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；")]),t._v(" "),a("li",[t._v("HTTP/2.0 「多路复用」多个请求可同时在一个连接上并行执行，某个请求任务耗时严重，不会影响到其它连接的正常执行；")])])])])])}),[],!1,null,null,null);s.default=r.exports}}]);